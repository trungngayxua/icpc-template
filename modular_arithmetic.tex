Modular Arithmetic Cheat Sheet (CP-oriented)

Mục tiêu: tổng hợp tính chất, bẫy thường gặp, và công thức/thuật toán quan trọng xoay quanh phép đồng dư. Tập trung vào vai trò số nguyên tố, khả năng nghịch đảo, và CRT.

1) Cơ bản và ký hiệu
- a \equiv b (mod m) ⇔ m | (a-b). Luôn có thể chuẩn hoá a ← ((a % m) + m) % m.
- Khi m = 1: mọi số đều \equiv 0 (mod 1).
- Tính cộng/trừ/nhân: bảo toàn đồng dư. Chia chỉ hợp lệ khi có nghịch đảo.

2) Nghịch đảo và khử nhân tử (cancellation)
- a có nghịch đảo modulo m ⇔ gcd(a, m) = 1. Khi đó tồn tại a^{-1} s.t. a·a^{-1} \equiv 1 (mod m).
- Hệ quả “ẩn” thường bị lợi dụng:
  • Nếu u·v \equiv 1 (mod M) ⇒ gcd(u, M) = gcd(v, M) = 1 (cả hai đều khả nghịch).
  • Nếu a·x \equiv a·y (mod m) và gcd(a, m) = 1 ⇒ x \equiv y (mod m) (khử a được).
  • Nếu gcd(a, m) = g > 1, khi đó từ a·x \equiv b (mod m) có nghiệm iff g | b; có đúng g nghiệm khác nhau mod m, bước nhảy m/g.
- Tồn tại “zero divisors” khi m hợp số: a·b \equiv 0 (mod m) chưa chắc a \equiv 0 hoặc b \equiv 0 (bẫy chia).

3) Số nguyên tố và trường F_p
- Với p nguyên tố, Z/pZ là trường ⇒ mọi a ≠ 0 đều khả nghịch; phép chia hợp lệ.
- Định lý Fermat nhỏ (FLT): a^{p-1} \equiv 1 (mod p) nếu p \nmid a. Suy ra a^{-1} \equiv a^{p-2} (mod p).
- Định lý Euler: a^{\varphi(m)} \equiv 1 (mod m) nếu gcd(a, m) = 1. Với m hợp số, chu kỳ mũ chia hết \varphi(m) nhưng thường ngắn hơn: λ(m) (hàm Carmichael) là bậc mũ nhỏ nhất chung.
- Bậc (order) của a modulo m: ord_m(a) là số nhỏ nhất d>0 s.t. a^d \equiv 1 (mod m) (tồn tại khi gcd(a,m)=1). ord_m(a) | λ(m) | \varphi(m).
- Số nguyên tố nguyên thuỷ (primitive root): với p nguyên tố, tồn tại g nguyên thủy sao cho bậc của g là p−1. Tồn tại primitive root cho: p, 2, 4, 2·p^k, p^k (p lẻ).

4) CRT (Chinese Remainder Theorem)
- Nếu m_1, m_2,…, m_k đôi một nguyên tố cùng nhau, thì hệ x \equiv a_i (mod m_i) có nghiệm duy nhất mod M = \prod m_i. Có thể dùng Garner/CRT construct để hợp nhất.
- Trường hợp không đồng nguyên tố: hệ x \equiv a (mod m), x \equiv b (mod n) có nghiệm iff a \equiv b (mod gcd(m,n)); khi có nghiệm, lớp nghiệm modulo lcm(m,n).
- Kỹ thuật thường gặp: tách modulo hợp số M thành modulo theo các p_i^{e_i}, giải từng phần, trộn lại bằng CRT.

5) Bài toán tuyến tính modulo
- Giải ax \equiv b (mod m): đặt g = gcd(a,m). Nếu g \nmid b ⇒ vô nghiệm. Ngược lại, rút g: a' = a/g, b' = b/g, m' = m/g; tìm nghịch đảo a'^{-1} mod m' ⇒ x_0 \equiv a'^{-1}·b' (mod m'); tất cả nghiệm là x \equiv x_0 + t·m' (t=0..g−1).
- Hệ phương trình tuyến tính modulo (ma trận): chỉ khả thi chia khi các pivot đồng nguyên tố với mod; dễ nhất trên trường (mod prime).

6) Lũy thừa, giai thừa, tổ hợp modulo
- powmod: nhị phân O(log e). Với mod prime p: inv(a) = a^{p-2} (FLT).
- (p-1)! \equiv −1 (mod p) (Wilson) ⇒ suy ra nghịch đảo nhanh cho tích liên tiếp.
- nCk mod p (p nguyên tố): tiền xử lý fact[i], invfact[i] mod p ⇒ C(n,k) = fact[n]·invfact[k]·invfact[n−k].
- Lucas: C(n,k) mod p = \prod C(n_i, k_i) theo biểu diễn p-adic (n_i,k_i là chữ số base p).
- Mod hợp số: phân rã theo CRT. Với p^e, cần xử lý bội số p (số mũ của p trong n!), đa số cần công thức Legendre + factorial bỏ bội p + CRT (nâng cao).

7) Căn bậc hai modulo (quadratic residues)
- Với p lẻ nguyên tố: x^2 \equiv a (mod p) có nghiệm ⇔ a^{(p-1)/2} \equiv 1 (mod p) (ký hiệu Legendre). Tìm nghiệm: Tonelli–Shanks. Nếu p \equiv 3 (mod 4): x \equiv \pm a^{(p+1)/4} (mod p).
- Mod hợp số: tách theo p_i^{e_i}, giải từng phần, CRT.

8) “Bẫy” và hiện tượng ẩn người ra đề hay dùng
- Chia modulo hợp số: không thể khử/đảo tuỳ tiện (zero divisors). Yêu cầu kiểm tra gcd trước khi khử.
- Đổi mod từ prime sang composite để phá công thức inv = a^{p-2}. Buộc dùng exgcd.
- Áp dụng sai FLT/Euler: a^{\varphi(m)} \equiv 1 chỉ đúng khi gcd(a,m)=1; với Carmichael numbers, Fermat test đánh lừa.
- “Chu kỳ mũ” thực tế theo λ(m), không nhất thiết \varphi(m). Setter có thể dùng số có λ(m) nhỏ để gây nhiễu.
- CRT không đồng nguyên tố: bắt buộc kiểm tra điều kiện tương thích a \equiv b (mod gcd).
- Đếm nghiệm ax \equiv b: luôn là g = gcd(a,m) nghiệm khác nhau mod m (nếu có nghiệm) — hay bị bỏ sót.
- Bình phương modulo p \equiv 3 (mod 4) nhanh, nhưng p \equiv 1 (mod 4) cần Tonelli–Shanks.
- Chuẩn hoá âm: nhiều lỗi do (−x) % m âm; luôn chuẩn hoá về [0, m).

9) Mẫu code thường dùng (C++)

// powmod, exgcd, inv, CRT (2 phương trình)
\begin{verbatim}
long long modpow(long long a, long long e, long long m){
    long long r=1%m; a%=m; while(e){ if(e&1) r=(__int128)r*a % m; a=(__int128)a*a % m; e>>=1; } return r; }

long long exgcd(long long a, long long b, long long &x, long long &y){
    if(!b){ x= (a>=0?1:-1); y=0; return llabs(a);} long long x1,y1; long long g=exgcd(b,a%b,x1,y1);
    x=y1; y=x1 - (a/b)*y1; return g; }

// inv(a) mod m, trả -1 nếu không tồn tại
long long invmod(long long a, long long m){ long long x,y; long long g=exgcd(a,m,x,y); if(g!=1) return -1; x%=m; if(x<0) x+=m; return x; }

// CRT cho hai phương trình: x \equiv a1 (mod m1), x \equiv a2 (mod m2)
// Trả {x0, lcm} (x0 trong [0, lcm)), hoặc {0, -1} nếu vô nghiệm
pair<long long,long long> crt2(long long a1,long long m1,long long a2,long long m2){
    a1%=m1; if(a1<0) a1+=m1; a2%=m2; if(a2<0) a2+=m2;
    long long x,y; long long g=exgcd(m1,m2,x,y);
    if((a2-a1)%g) return {0,-1};
    __int128 lcm = (__int128)m1/g*m2;
    __int128 t = (__int128)(a2-a1)/g * x % (m2/g);
    long long r = (long long)((a1 + t*m1) % lcm); if(r<0) r += (long long)lcm;
    return {r,(long long)lcm};
}
\end{verbatim}

// nCk mod p (p nguyên tố) với tiền xử lý factorial
\begin{verbatim}
struct CombModP{
    int p; vector<long long> fact, invfact;
    long long modpow(long long a,long long e){ long long r=1; while(e){ if(e&1) r=r*a%p; a=a*a%p; e>>=1;} return r; }
    CombModP(int P,int Nmax):p(P){ fact.resize(Nmax+1); invfact.resize(Nmax+1); fact[0]=1; for(int i=1;i<=Nmax;i++) fact[i]=fact[i-1]*i%p; invfact[Nmax]=modpow(fact[Nmax],p-2); for(int i=Nmax;i>0;i--) invfact[i-1]=invfact[i]*i%p; }
    long long C(long long n,long long k){ if(k<0||k>n) return 0; return fact[n]*invfact[k]%p*invfact[n-k]%p; }
};
\end{verbatim}

10) Gợi ý khi thiết kế lời giải mod
- Kiểm tra m là prime? composite? có cần CRT? có zero divisors?
- Có thể nén giá trị để tần suất/đếm? Có dùng nhóm đơn vị (gcd=1)?
- Chu kỳ mũ/đơn vị có giúp giảm số mũ? Phân rã theo prime powers?
- Cần “chia” không? Nếu có, đảm bảo gcd=1 hoặc dùng exgcd để tìm nghịch đảo.
- Đọc kĩ đề: nhiều bài cố tình đưa modulus “khó chịu” để kiểm tra hiểu biết trên.

